# Netty 物联网通信协议架构设计

# 运行项目

先跑 im.zhiyi.boot.netty.iot.starter.demo.NettyDemoApplication

再跑 im.zhiyi.boot.netty.iot.starter.demo.NettyDemoApplicationTest


# 通信流程

工作中，经常遇到使用企业内自定义的数据包格式, 而 netty 也提供了相关解码器， 尤其是物联网项目中，经常会遇到使用长连接与硬件24小时保持连接, 对于长连接其实可以直接用MQTT这种协议。为什么有些企业不使用这种通用的协议，而是要自定义协议呢？我觉得可能是开发简单（偷懒），如果硬件需要上网，就需要一个通信模块， 我知道的有SIM800C模块， 这种通信模块有一种透传模式，硬件从串口的数据，都会被发送给事先设定好的ip:port, 并且硬件绝大多数开发都是采用的C语言，而C语言的中的结构体有一个特点，就是占用的内存等于结构体中的每一个变量所占内存的和，也就说，硬件如果直接把一个结构体直接发出来，那么服务端拿到的就是这个结构体二进制数组，硬件只要告诉你他的结构体，你就能 "拆" 出变量。

一般都是服务器是TCP的服务端， 硬件是客户端，硬件通电以后就连接服务器，不过反过来的情况也有，比如硬件都是固定IP的，一般是你要集成别人的硬件的时候遇到。我们这里是用软件模拟硬件， 也就说，两种模式都要写。其实对于特定数据包，往往只要完成一个解码或者是完成编码就行。如果是硬件发送给你的数据包，那么你只要完成解码就行，如果是发送给硬件的，那么你只要完成编码就行。不过我一般都会完成编解码，主要是方便测试，充当模拟器使用。


# 数据包结构

这里举例一个自定义数据包

|名称|偏移位置|长度|备注|
|--------|--------|--------|--------|
|包头|0|1|固定 0xA5| 
|数据长度|2|1|数据体字节数| 
|类型|3|1|0-127|
|数据|4|n|协议类型决定|
|校验码|n+4|1|数据体字节的校验值| 校验规则将数据体每一位异或

根据上面的格式,模拟一个包含一个int型的id,和short型的version数据包

```
A5 06 01 01 00 00 00 64 00 65
```
包头: 0xA5
长度: 0x06
类型: 0x01 
数据体: id: 01 0x00 0x00 0x00 十进制的: 1;  version: 0x64 0x00 十进制的100; // 4+2刚好等于长度6
校验码: 65 

# 校验码

网络传输使用的是TCP协议，为什么还需要设置校验码，防止出错呢？ 首先要明白硬件是通过串口发送给通信模块，在由通信模块转发出来的，校验码，只要是为了防止这一段过程中，出现了乱码，其实可以在通信模块上，做数据校验，不过一般通信模块都是买现成的，也没有人去开发编程。


# 认证数据包

认证即鉴权，是为了防止设备ID重复，或者是对故障设备，或他人设备进行通信。一般简单的就是设置一个随机的硬件id，或者是使用硬件的上的唯一码作为通信id，例如IMES，鉴权包，一般都是设备连接上来以后的第一个数据包，硬件应该保证上报的第一个包为鉴权，再未收到鉴权成功以前，不允许上报其他的数据吧，同时服务端也应该再设备连接上来以后，首要解析的是鉴权包， 如果收到其他的数据包，应该返回错误包，或者直接断开连接。如果设备是犹豫网络不稳定，而造成的重连的时候，应设置一个标志位，表示当前设备是重连。这一点主要是为了考虑到对设备的初始化，和任务的继续。例如，设备是有正常关机按钮的，业务会讲设备的开关机作为一个任务，再设备开机为一个任务的开始，关机为一个任务的结束，如果设备因外部因素导致断网，后台将任务标记为结束，现在多了这个标志位，硬件重连的时候，后台可以看作是原来任务的继续。

# 重连机制

这部分针对的是client，在断开后，进行重来机制。思路就是先定时器，定时遍历所有设备的连接状态。这里为什么不采用在断开连接时候，直接去重连呢，主要是，有两种情况下，需要重连，一种是首次连接失败重连【INIT】状态，一种是断开连接后重连【RECONNECT】状态。而且，在断开连接以后，得延迟一段日志重新连接，不然会一直在不停的重连。所以，我采用了定时器遍历，只要状态不是【CONNECTED】，就进行重连，只需要在上述两种情况中设置对于的状态位就行。


# 心跳数据包

为什么要有心跳包， 主要是如果依靠TCP底层的断开连接包的话，是在正常断开连接下，其实tcp自己就有心跳包，但是这个不一定好用哟， 所谓的tcp长连接，其实也就是定时发送心跳包，检查链路是否正常，当时很多智能硬件，上网都是靠数传模块，也就是说，其实智能硬件看到的不是tcp，而是串口数据，串口并没有tcp那种特性，知道发出去的有没有人被接受，差不多就是UDP了，所以硬件会启动一个看门狗程序，和一个定时器，定时器会定时发送上报心跳包，如果服务器收到后，就会下发回应心跳包，看门狗就会重新初始化，反之，如果没有收到，看门狗会重启数传模块，达到重连效果。服务器也需要去判断，从而确定硬件是否正常，因为数传模块和智能硬件可是独立的，有可能数传是正常的，但是硬件已经挂掉了，从而就不会发送心跳包，这种情况，也需要服务器主动断开连接，更加严谨一点，可以让服务器主动下发心跳包，让硬件回应。达到双工效果。Netty 自带一个可以处理TCP读写空闲事件，如果硬件长时间未上报数据，超过预先设置的空闲时间，那么就得断开连接了。


# 代码结构

我将代码分成了三个模块, 主要为了整合进不同的框架结构

```xml
<!-- 无框架 -->
<dependency>
    <groupId>im.zhiyi.boot</groupId>
    <artifactId>zhiyi-netty-iot</artifactId>
</dependency>
<!-- 整合spring,主要是ssm架构 -->
<dependency>
    <groupId>im.zhiyi.boot</groupId>
    <artifactId>zhiyi-netty-iot-spring</artifactId>
</dependency>
<!-- 整合spring boot -->
<dependency>
    <groupId>im.zhiyi.boot</groupId>
    <artifactId>zhiyi-netty-iot-boot-starter</artifactId>
</dependency>
```

# 设计思想

1. 解析一个完整数据包，，这一部分，netty已经提供了和完善得配置，我这里采用得是基于LengthFieldBasedFrameDecoder
2. 解析数据，数据包中必须包含数据类型type，我提供了配置，需要你帮我指出哪部分数据是type变量
3. 数据格式一般为： 头 + 数据 + 尾；其中头尾格式不变
4. 你得告诉我不同type数据包由哪个实现类负责解析，（通过添加注解明确）
5. 你得告诉我写出好得实体类得发给那个业务处理类处理
6. 如果你觉得声明两个实体类太麻烦，也可以合并为一个（即负责协议解析，有负责业务处理）

# 使用演示

演示整合springboot的,其他两种情况请看对应测试用例即可

zhiyi-netty-iot-boot-starter 这是一个模板，内置了一套自定义协议格式,(就是上面举例格式)，也可以根据需要配置协议格式。
也是一个路由，可以把不同类型的数据包分发给不同的处理器
默认启动监听8000端口

```yaml
zhiyi:
  netty:
    iot:
      coder:
        byte-order: 0 # 数据是大端还是小端 0小端 1大端
        max-frame-length: 2048 # 包的最大长度
        length-field-offset: 1 # 长度域的偏移量
        length-field-length: 2 # 记录该帧数据长度的字段本身的长度
        length-adjustment: 4 # 该字段加长度字段等于数据帧的长度
        initial-bytes-to-strip: 0 #  从数据帧中跳过的字节数
        fail-fast: true # 超过 max-frame-length，就抛出一个 TooLongFrameException
        type-field-length: 1 # 记录该帧数据类型的字段本身的长度
        type-field-offset: 2 #类型域的偏移量
      server:
        port: 8010 # 端口
        enable: true # 启动服务
```
## 参数说明

根据上面的解释
因为length一个字节，所以length-field-length=1，并且前面还有一个字节，所以length-field-offset=1，

因为一个完整数据包等于length+4，所以length-adjustment=4，

因为包和包直接不存在其他数据，所以initial-bytes-to-strip=0

因为type一个字节，所以type-field-length=1，并且前面还有两个字节所以type-field-offset=2。

## 自定义数据格式

实现接口im.zhiyi.boot.netty.iot.coder.NettyPackageCoder，加Component组件生效

默认实现im.zhiyi.boot.netty.iot.DefaultNettyPackageCoder（看完可以少踩坑）

##  ProtocolBody  编解码接口,需要使用@NettyPackageScan扫描范围内

1. 必须包含无参构造
2. 不要再这里使用Spring的东西

## BasePackageHandler 业务处理接口

1. 要加Component组件生效
2. 在这里写业务CRUD
3. 一个AuthPackage最好一个BasePackageHandler处理，不过多个的话也都会处理

# 视频讲解

公众号回复 netty 获取视频链接

![](http://oss.flizi.cn/blog/zymy.jpg)